---
title: "Final_First_Visualization"
author: '111071048'
date: "2025-11-05"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Load package and file

```{r}
library(tidyverse)
library(stringr)
library(dplyr)
library(ggplot2)

# read CSV 
df_raw <- read_csv(
  "Drug_overdose_death_rates__by_drug_type__sex__age__race__and_Hispanic_origin__United_States.csv",
  col_types = cols(.default = col_character())
)

# Replace empty strings with NA across the entire dataframe *before* conversions
df_raw[df_raw == ""] <- NA

# Create a working copy of the dataframe
df <- df_raw

# Define column types and apply conversions
# Categorical columns remain as factor, numerical columns are converted, "*" becomes NA
categorical_cols_names <- c("INDICATOR", "PANEL", "UNIT", "STUB_NAME", "STUB_LABEL", "AGE", "FLAG")
numerical_cols_names <- c("PANEL_NUM", "UNIT_NUM", "STUB_NAME_NUM", "STUB_LABEL_NUM", "YEAR", "YEAR_NUM", "AGE_NUM", "ESTIMATE")

# Convert numerical columns.  This will implicitly handle '*' as NA because it's non-numeric
for (col in numerical_cols_names) {
  df[[col]] <- as.numeric(df[[col]]) # Any invalid numeric will be NA
}

# Convert categorical columns to factor
for (col in categorical_cols_names) {
  df[[col]] <- as.factor(df[[col]])
}

# 1. List data types
cat("--- Data Types ---\n")
print(sapply(df, class))

```

## 2. Categorical Data Analysis

```{r}
# Categorical Data Analysis
cat("\n--- Categorical Data Analysis ---\n")
for (col_name in categorical_cols_names) {
  cat("\nColumn:", col_name, "\n")
  
  # Missing values
  na_count <- sum(is.na(df[[col_name]]))
  cat("  Missing values (NA):", na_count, "\n")
  
  # Unique values (including NA)
  unique_vals <- unique(df[[col_name]])
  
  cat("  Unique values (including NA):", paste(unique_vals, collapse = ", "), "\n")
}

# Set up plot area for categorical plots
par(mfrow = c(3, 3), mar = c(4, 4, 2, 1))

for (col_name in categorical_cols_names) 
  cat("\nColumn:", col_name, "\n")
  
  # Missing values
  na_count <- sum(is.na(df[[col_name]]))
  cat("  Missing values (NA):", na_count, "\n")
  
  # Unique values (including NA)
  unique_vals <- unique(df[[col_name]])
  cat("  Unique values (count:", length(unique_vals), "): ", paste(head(unique_vals, 10), collapse = ", "), "...\n")
  
```
### categorical distribution plot
```{r}
# Loop through each categorical column to create a separate plot
for (col_name in categorical_cols_names) {
  
  # --- Print summary to console ---
  cat("\n--- Analyzing Column:", col_name, "---\n")
  
  # Count missing values
  na_count <- sum(is.na(df[[col_name]]))
  cat("  Missing values (NA):", na_count, "\n")
  
  # Get unique values and their count
  unique_vals <- unique(df[[col_name]])
  cat("  Number of unique values:", length(unique_vals), "\n")
  
  # --- Plotting ---
  # Only create a plot if the number of unique values is manageable (e.g., less than 50)
  if (length(unique_vals) < 50) {
    
    # Set plot margins to make space for labels (bottom, left, top, right)
    # We need more space at the bottom for long labels
    par(mar = c(10, 4, 4, 2) + 0.1)
    
    # Create the bar plot
    barplot(table(df[[col_name]]), 
            main = paste("Distribution of", col_name), 
            ylab = "Frequency",
            col = "lightblue",
            las = 2) # Makes axis labels perpendicular for readability
            
    cat("  A bar plot for '", col_name, "' has been generated.\n")
    
  } else {
    # If there are too many unique values, skip plotting to avoid a messy chart
    cat("  (Skipping plot for '", col_name, "' because it has too many unique values:", length(unique_vals), ")\n")
  }
}

# Reset plot margins to default after the loop
par(mar = c(5, 4, 4, 2) + 0.1)

```

## 3. Numerical Data Analysis
```{r}
# Numerical Data Analysis
cat("\n--- Numerical Data Analysis ---\n")
for (col_name in numerical_cols_names) {
  cat("\nColumn:", col_name, "\n")
  
  # Missing values
  na_count <- sum(is.na(df[[col_name]]))
  cat("  Missing values (NA):", na_count, "\n")
  
  # Plot distribution
  if (na_count < nrow(df)) { # Only plot if there's actual data to plot
    plot_data <- df[[col_name]]
    plot_data <- plot_data[!is.na(plot_data)] # Remove NA for plotting
    
    if (length(plot_data) > 0) { # Ensure there's still data after removing NA
      p <- ggplot(data.frame(x = plot_data), aes(x = x)) +
        geom_histogram(binwidth = (max(plot_data, na.rm = TRUE) - min(plot_data, na.rm = TRUE)) / 30, fill = "skyblue", color = "black") +
        labs(title = paste("Distribution of", col_name), x = col_name, y = "Frequency") +
        theme_minimal()
      print(p)
    } else {
      cat("  No non-NA values to plot for distribution after NA removal.\n")
    }
  } else {
    cat("  No non-NA values to plot for distribution.\n")
  }
}
```


# 4. Summary of EDA
```{r}
library(dplyr)
library(tibble)

# Categorical summary
cat_summary <- categorical_cols_names %>%
  lapply(function(col) {
    data.frame(
      Column = col,
      Missing = sum(is.na(df[[col]])),
      Unique_Count = length(unique(df[[col]])),
      Example_Values = paste(head(unique(df[[col]]), 5), collapse = "; ")
    )
  }) %>%
  bind_rows()

# Numerical summary
num_summary <- numerical_cols_names %>%
  lapply(function(col) {
    data.frame(
      Column = col,
      Missing = sum(is.na(df[[col]])),
      Min = min(df[[col]], na.rm = TRUE),
      Max = max(df[[col]], na.rm = TRUE),
      Mean = mean(df[[col]], na.rm = TRUE)
    )
  }) %>%
  bind_rows()

cat_summary
num_summary
```


